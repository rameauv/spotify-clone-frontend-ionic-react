/* tslint:disable */
/* eslint-disable */
/**
 * SpotifyAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import {Configuration} from './configuration';
import globalAxios, {AxiosInstance, AxiosPromise, AxiosRequestConfig} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
    assertParamExists,
    createRequestFunction,
    DUMMY_BASE_URL,
    serializeDataIfNeeded,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    toPathString
} from './common';
// @ts-ignore
import {BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError} from './base';

/**
 *
 * @export
 * @interface ArtistResultDto
 */
export interface ArtistResultDto {
    /**
     *
     * @type {string}
     * @memberof ArtistResultDto
     */
    'id'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ArtistResultDto
     */
    'thumbnailUrl'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ArtistResultDto
     */
    'name'?: string | null;
}

/**
 *
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     *
     * @type {string}
     * @memberof CreateUserDto
     */
    'username'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateUserDto
     */
    'password'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateUserDto
     */
    'data'?: string | null;
}

/**
 *
 * @export
 * @interface DateOnly
 */
export interface DateOnly {
    /**
     *
     * @type {number}
     * @memberof DateOnly
     */
    'year'?: number;
    /**
     *
     * @type {number}
     * @memberof DateOnly
     */
    'month'?: number;
    /**
     *
     * @type {number}
     * @memberof DateOnly
     */
    'day'?: number;
    /**
     *
     * @type {DayOfWeek}
     * @memberof DateOnly
     */
    'dayOfWeek'?: DayOfWeek;
    /**
     *
     * @type {number}
     * @memberof DateOnly
     */
    'dayOfYear'?: number;
    /**
     *
     * @type {number}
     * @memberof DateOnly
     */
    'dayNumber'?: number;
}

/**
 *
 * @export
 * @enum {string}
 */

export const DayOfWeek = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6
} as const;

export type DayOfWeek = typeof DayOfWeek[keyof typeof DayOfWeek];


/**
 *
 * @export
 * @interface ErrorDto
 */
export interface ErrorDto {
    /**
     *
     * @type {HttpStatusCode}
     * @memberof ErrorDto
     */
    'code'?: HttpStatusCode;
    /**
     *
     * @type {string}
     * @memberof ErrorDto
     */
    'message'?: string | null;
}

/**
 *
 * @export
 * @enum {string}
 */

export const HttpStatusCode = {
    NUMBER_100: 100,
    NUMBER_101: 101,
    NUMBER_102: 102,
    NUMBER_103: 103,
    NUMBER_200: 200,
    NUMBER_201: 201,
    NUMBER_202: 202,
    NUMBER_203: 203,
    NUMBER_204: 204,
    NUMBER_205: 205,
    NUMBER_206: 206,
    NUMBER_207: 207,
    NUMBER_208: 208,
    NUMBER_226: 226,
    NUMBER_300: 300,
    NUMBER_301: 301,
    NUMBER_302: 302,
    NUMBER_303: 303,
    NUMBER_304: 304,
    NUMBER_305: 305,
    NUMBER_306: 306,
    NUMBER_307: 307,
    NUMBER_308: 308,
    NUMBER_400: 400,
    NUMBER_401: 401,
    NUMBER_402: 402,
    NUMBER_403: 403,
    NUMBER_404: 404,
    NUMBER_405: 405,
    NUMBER_406: 406,
    NUMBER_407: 407,
    NUMBER_408: 408,
    NUMBER_409: 409,
    NUMBER_410: 410,
    NUMBER_411: 411,
    NUMBER_412: 412,
    NUMBER_413: 413,
    NUMBER_414: 414,
    NUMBER_415: 415,
    NUMBER_416: 416,
    NUMBER_417: 417,
    NUMBER_421: 421,
    NUMBER_422: 422,
    NUMBER_423: 423,
    NUMBER_424: 424,
    NUMBER_426: 426,
    NUMBER_428: 428,
    NUMBER_429: 429,
    NUMBER_431: 431,
    NUMBER_451: 451,
    NUMBER_500: 500,
    NUMBER_501: 501,
    NUMBER_502: 502,
    NUMBER_503: 503,
    NUMBER_504: 504,
    NUMBER_505: 505,
    NUMBER_506: 506,
    NUMBER_507: 507,
    NUMBER_508: 508,
    NUMBER_510: 510,
    NUMBER_511: 511
} as const;

export type HttpStatusCode = typeof HttpStatusCode[keyof typeof HttpStatusCode];


/**
 *
 * @export
 * @interface LoginCredentialsDto
 */
export interface LoginCredentialsDto {
    /**
     *
     * @type {string}
     * @memberof LoginCredentialsDto
     */
    'username'?: string | null;
    /**
     *
     * @type {string}
     * @memberof LoginCredentialsDto
     */
    'password'?: string | null;
    /**
     *
     * @type {string}
     * @memberof LoginCredentialsDto
     */
    'deviceId'?: string;
}

/**
 *
 * @export
 * @interface NewAccessTokenDto
 */
export interface NewAccessTokenDto {
    /**
     *
     * @type {string}
     * @memberof NewAccessTokenDto
     */
    'accessToken'?: string | null;
}

/**
 *
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: any;

    /**
     *
     * @type {string}
     * @memberof ProblemDetails
     */
    'type'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ProblemDetails
     */
    'title'?: string | null;
    /**
     *
     * @type {number}
     * @memberof ProblemDetails
     */
    'status'?: number | null;
    /**
     *
     * @type {string}
     * @memberof ProblemDetails
     */
    'detail'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ProblemDetails
     */
    'instance'?: string | null;
}

/**
 *
 * @export
 * @interface ReleaseResultDto
 */
export interface ReleaseResultDto {
    /**
     *
     * @type {string}
     * @memberof ReleaseResultDto
     */
    'id'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ReleaseResultDto
     */
    'thumbnailUrl'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ReleaseResultDto
     */
    'title'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ReleaseResultDto
     */
    'artistName'?: string | null;
}

/**
 *
 * @export
 * @interface SearchResultDto
 */
export interface SearchResultDto {
    /**
     *
     * @type {Array<ReleaseResultDto>}
     * @memberof SearchResultDto
     */
    'releaseResults'?: Array<ReleaseResultDto> | null;
    /**
     *
     * @type {Array<SongResultDto>}
     * @memberof SearchResultDto
     */
    'songResult'?: Array<SongResultDto> | null;
    /**
     *
     * @type {Array<ArtistResultDto>}
     * @memberof SearchResultDto
     */
    'artistResult'?: Array<ArtistResultDto> | null;
}

/**
 *
 * @export
 * @interface SearchResultDtoResultDto
 */
export interface SearchResultDtoResultDto {
    /**
     *
     * @type {SearchResultDto}
     * @memberof SearchResultDtoResultDto
     */
    'result'?: SearchResultDto;
    /**
     *
     * @type {ErrorDto}
     * @memberof SearchResultDtoResultDto
     */
    'error'?: ErrorDto;
}

/**
 *
 * @export
 * @interface SongResultDto
 */
export interface SongResultDto {
    /**
     *
     * @type {string}
     * @memberof SongResultDto
     */
    'id'?: string | null;
    /**
     *
     * @type {string}
     * @memberof SongResultDto
     */
    'thumbnailUrl'?: string | null;
    /**
     *
     * @type {string}
     * @memberof SongResultDto
     */
    'title'?: string | null;
    /**
     *
     * @type {string}
     * @memberof SongResultDto
     */
    'artistName'?: string | null;
}

/**
 *
 * @export
 * @interface WeatherForecast
 */
export interface WeatherForecast {
    /**
     *
     * @type {DateOnly}
     * @memberof WeatherForecast
     */
    'date'?: DateOnly;
    /**
     *
     * @type {number}
     * @memberof WeatherForecast
     */
    'temperatureC'?: number;
    /**
     *
     * @type {number}
     * @memberof WeatherForecast
     */
    'temperatureF'?: number;
    /**
     *
     * @type {string}
     * @memberof WeatherForecast
     */
    'summary'?: string | null;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {LoginCredentialsDto} [loginCredentialsDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLoginPost: async (loginCredentialsDto?: LoginCredentialsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Accounts/Login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCredentialsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRefreshAccessTokenPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Accounts/RefreshAccessToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {CreateUserDto} [createUserDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegisterPost: async (createUserDto?: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Accounts/Register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {LoginCredentialsDto} [loginCredentialsDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLoginPost(loginCredentialsDto?: LoginCredentialsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewAccessTokenDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLoginPost(loginCredentialsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRefreshAccessTokenPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewAccessTokenDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRefreshAccessTokenPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {CreateUserDto} [createUserDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRegisterPost(createUserDto?: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRegisterPost(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         *
         * @param {LoginCredentialsDto} [loginCredentialsDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLoginPost(loginCredentialsDto?: LoginCredentialsDto, options?: any): AxiosPromise<NewAccessTokenDto> {
            return localVarFp.accountsLoginPost(loginCredentialsDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRefreshAccessTokenPost(options?: any): AxiosPromise<NewAccessTokenDto> {
            return localVarFp.accountsRefreshAccessTokenPost(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CreateUserDto} [createUserDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegisterPost(createUserDto?: CreateUserDto, options?: any): AxiosPromise<void> {
            return localVarFp.accountsRegisterPost(createUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     *
     * @param {LoginCredentialsDto} [loginCredentialsDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsLoginPost(loginCredentialsDto?: LoginCredentialsDto, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsLoginPost(loginCredentialsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsRefreshAccessTokenPost(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsRefreshAccessTokenPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {CreateUserDto} [createUserDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsRegisterPost(createUserDto?: CreateUserDto, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsRegisterPost(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [q]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSearchPost: async (q?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Search/Search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} [q]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSearchPost(q?: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResultDtoResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSearchPost(q, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         *
         * @param {string} [q]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSearchPost(q?: string, offset?: number, limit?: number, options?: any): AxiosPromise<SearchResultDtoResultDto> {
            return localVarFp.searchSearchPost(q, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     *
     * @param {string} [q]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchSearchPost(q?: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchSearchPost(q, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WeatherForecastApi - axios parameter creator
 * @export
 */
export const WeatherForecastApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeatherForecast: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/WeatherForecast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WeatherForecastApi - functional programming interface
 * @export
 */
export const WeatherForecastApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = WeatherForecastApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWeatherForecast(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WeatherForecast>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWeatherForecast(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WeatherForecastApi - factory interface
 * @export
 */
export const WeatherForecastApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WeatherForecastApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeatherForecast(options?: any): AxiosPromise<Array<WeatherForecast>> {
            return localVarFp.getWeatherForecast(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WeatherForecastApi - object-oriented interface
 * @export
 * @class WeatherForecastApi
 * @extends {BaseAPI}
 */
export class WeatherForecastApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WeatherForecastApi
     */
    public getWeatherForecast(options?: AxiosRequestConfig) {
        return WeatherForecastApiFp(this.configuration).getWeatherForecast(options).then((request) => request(this.axios, this.basePath));
    }
}


